import re
from typing import Callable, Iterator

# Число: опционально знак, целая часть, опционально - дробная через точку
# Ограничение по краям: перед/после нет непробельных символов (то есть пробел или граница строки)

#Регуляторка для поиска действительных чисел в тексте честно сгенерирована с помощью GPT(моих мозгов не хватило :)

#(?<!\S) — негативный просмотр назад: слева нет непробельного символа ⇒ слева либо пробел, либо начало строки.
#[+-]? — необязательный знак + или -.
#\d+ — одна или более цифр (целая часть).
#(?:\.\d+)? — необязательная некопирующая группа: точка и одна/более цифр (дробная часть). Некопирующая (?:) — чтобы не плодить нумерованные группы; мы будем брать всё совпадение целиком.
#(?!\S) — негативный просмотр вперёд: справа нет непробельного символа ⇒ справа либо пробел, либо конец строки.

_NUMBER_RE = re.compile(r'(?<!\S)[+-]?\d+(?:\.\d+)?(?!\S)')

def generator_numbers(text: str) -> Iterator[float]:
    """находим в тексте все числа и возвращаем их по одному в виде float."""
    for m in _NUMBER_RE.finditer(text):
        yield float(m.group()) # генератор в генераторе, ну круто же :)

def sum_profit(text, func):
    """Суммируем все числа, возвращённые генератором func(text).
    и вместо понятного всем цикла с аккумулятором: 
    summ = 0.0
    for number in func(text):
        summ += number
    используем встроенную функцию sum(): которая принимает генератор и сама итерируется по нему, суммируя значения.
    генератор→ генератор→ потребитель генерации.. жжжжесть. я этого никогда до конца не пойму :D  
    """
    return sum(func(text))


# Пример
if __name__ == "__main__":
    text = ("Общий доход работника состоит из нескольких частей: 1000.01 как основной доход, "
            "дополненный дополнительными поступлениями 27.45 и 324.00 долларов.")
    total_income = sum_profit(text, generator_numbers)
    print(f"Общий доход: {total_income}")  # => Общий доход: 1351.46
